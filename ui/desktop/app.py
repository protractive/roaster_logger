from __future__ import annotations

import sys
import time
import json
import shutil
from datetime import datetime
from pathlib import Path
from typing import Any, Callable, Optional

try:
    from appdirs import user_config_dir, user_data_dir
except ModuleNotFoundError:  # fallback if appdirs is missing
    def user_config_dir(appname: str) -> str:
        return str(Path.home() / f".{appname}" / "config")

    def user_data_dir(appname: str) -> str:
        return str(Path.home() / f".{appname}" / "data")

from PySide6.QtCore import QThread, Signal, QTimer
from PySide6.QtCharts import QChart, QChartView, QDateTimeAxis, QValueAxis, QLineSeries
from PySide6.QtCore import QDateTime, Qt
from PySide6.QtGui import QPainter
from PySide6.QtWidgets import (
    QApplication,
    QComboBox,
    QDialog,
    QDialogButtonBox,
    QFormLayout,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMainWindow,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QToolButton,
    QCheckBox,
    QTabWidget,
    QDoubleSpinBox,
    QGroupBox,
    QVBoxLayout,
    QWidget,
    QPlainTextEdit,
    QSplitter,
)

from config import load_settings, add_or_update_port, save_settings
from core.bus import ModbusBus, load_port_configs, stub_client_factory, pymodbus_client_factory
from core.session import Session
from logging_pipeline.schemas import LogRecord
from logging_pipeline.writer import CycleLogWriter
from ui.desktop.port_editor import PortEditorDialog


def _client_factory(name: str) -> Callable[..., Any]:
    if name == "pymodbus":
        return pymodbus_client_factory
    return stub_client_factory


def ensure_runtime_paths() -> None:
    """Ensure config/log paths exist and seed a default settings file if missing."""
    app_name = "roaster_logger"
    config_dir = Path(user_config_dir(app_name))
    data_dir = Path(user_data_dir(app_name)) / "logs"
    config_dir.mkdir(parents=True, exist_ok=True)
    data_dir.mkdir(parents=True, exist_ok=True)
    settings_path = config_dir / "settings.toml"
    needs_seed = not settings_path.exists()
    if not needs_seed:
        try:
            import tomllib
        except ModuleNotFoundError:
            import tomli as tomllib  # type: ignore
        try:
            with settings_path.open("rb") as fh:
                data = tomllib.load(fh)
            # ensure required sections exist
            needs_seed = not all(k in data for k in ("app", "logging", "ports"))
        except Exception:
            needs_seed = True

    if needs_seed:
        default_settings = """# autogenerated settings
[app]
name = "roaster_logger"
env = "local"
log_dir = "data/logs"

[logging]
level = "INFO"
format = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
max_bytes = 1048576
backup_count = 5

# Add ports via UI or edit manually. Example:
# [[ports]]
# id = "roaster_1"
# device = "COM3"
# baudrate = 9600
# parity = "N"
# stopbits = 1
# bytesize = 8
# timeout = 1.0
# poll_interval = 1.0
# unit_id = 1
# read_address = 0
# read_count = 10
# value_index = 0
# enabled = true

ports = []
"""
        settings_path.write_text(default_settings.strip() + "\n", encoding="utf-8")
    return settings_path


class ReadWorker(QThread):
    log_line = Signal(str)
    data_point = Signal(str, float, float)  # port_id, timestamp epoch seconds, value
    status = Signal(str)
    finished = Signal()

    def __init__(
        self,
        port_cfg,
        log_dir: Path,
        cycle_name: str,
        client: str,
        address: int,
        count: int,
        interval: float,
        value_index: int,
        bean_type: str = "",
        weight: float = 0.0,
        note: str = "",
        display_name: str = "",
    ) -> None:
        super().__init__()
        self.port_cfg = port_cfg
        self.log_dir = log_dir
        self.cycle_name = cycle_name
        self.display_name = display_name or cycle_name
        self.client = client
        self.address = address
        self.count = count
        self.interval = interval
        self.value_index = value_index
        self.bean_type = bean_type
        self.weight = weight
        self.note = note
        self._stop = False
        self._session_info_logged = False

    def stop(self) -> None:
        self._stop = True

    def run(self) -> None:
        bus = None
        session: Session | None = None
        try:
            bus = ModbusBus(self.port_cfg, client_factory=_client_factory(self.client))
            bus.connect()
            session = Session(
                cycle_name=self.cycle_name,
                log_dir=self.log_dir,
                record_writer_factory=lambda base_dir, name, ts: CycleLogWriter(base_dir, name, ts),
            )
            log_path = session.start()
            self.status.emit(f"Started cycle '{self.cycle_name}' -> {log_path}")
            self._log_session_info(session)
            while not self._stop:
                resp = bus.read_holding_registers(self.address, self.count)
                record = LogRecord(
                    timestamp=datetime.utcnow(),
                    port_id=self.port_cfg.id,
                    payload={"holding_registers": self._serialize_response(resp)},
                    meta={},
                )
                session.log(record)
                self.log_line.emit(f"{record.timestamp.isoformat()} {record.port_id} {record.payload}")
                value = self._extract_value(record.payload)
                if value is not None:
                    self.data_point.emit(self.port_cfg.id, record.timestamp.timestamp(), value)
                time.sleep(self.interval)
        except Exception as exc:  # noqa: BLE001
            self.status.emit(f"Error: {exc}")
        finally:
            if session:
                session.stop()
            if bus:
                bus.close()
            self.finished.emit()

    def _log_session_info(self, session: Session) -> None:
        if self._session_info_logged:
            return
        info = {
            "cycle_name": f"{self.display_name}_{self.port_cfg.id}",
            "bean_type": self.bean_type,
            "weight": self.weight,
            "note": self.note,
            "port_id": self.port_cfg.id,
        }
        record = LogRecord(
            timestamp=datetime.utcnow(),
            port_id=self.port_cfg.id,
            payload={"session_info": info},
            meta={},
        )
        session.log(record)
        self.log_line.emit(f"{record.timestamp.isoformat()} {record.port_id} session_info {info}")
        self._session_info_logged = True

    @staticmethod
    def _serialize_response(resp: Any) -> Any:
        if resp is None:
            return None
        if hasattr(resp, "registers"):
            return {"registers": getattr(resp, "registers")}
        if hasattr(resp, "bits"):
            return {"bits": getattr(resp, "bits")}
        try:
            import json

            json.dumps(resp)
            return resp
        except Exception:
            return repr(resp)

    def _extract_value(self, payload: Any) -> float | None:
        try:
            if isinstance(payload, dict):
                if "holding_registers" in payload:
                    data = payload["holding_registers"]
                else:
                    data = next(iter(payload.values()))
            else:
                data = payload
            if isinstance(data, dict) and "registers" in data:
                vals = data["registers"]
            elif isinstance(data, dict) and "values" in data:
                vals = data["values"]
            else:
                vals = data
            if isinstance(vals, list) and vals:
                idx = min(len(vals) - 1, max(0, int(self.value_index)))
                return float(vals[idx])
            if isinstance(vals, (int, float)):
                return float(vals)
            if isinstance(vals, dict):
                nums = [v for v in vals.values() if isinstance(v, (int, float))]
                if nums:
                    return float(nums[0])
        except Exception:
            return None
        return None


class MainWindow(QMainWindow):
    def __init__(self, settings_path: Path) -> None:
        super().__init__()
        self.setWindowTitle("Roaster Logger")
        self.settings_path = settings_path
        self.settings = load_settings(self.settings_path)
        self.ports = load_port_configs(self.settings)
        self.workers: list[ReadWorker] = []
        self.port_value_index: dict[str, int] = {}
        self.start_time: Optional[datetime] = None
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_elapsed)
        self.running = False

        # Widgets
        self.port_list = QListWidget()
        self.port_list.setSelectionMode(QListWidget.MultiSelection)
        self.client_combo = QComboBox()
        self.client_combo.addItems(["pymodbus", "stub"])
        self.use_enabled = QCheckBox("Use enabled ports automatically")
        self.use_enabled.setChecked(True)

        self.cycle_name = QLineEdit("gui_cycle")
        self.bean_type = QLineEdit()
        self.weight = QDoubleSpinBox()
        self.weight.setRange(0.0, 100000.0)
        self.weight.setSuffix(" g")
        self.weight.setSingleStep(10.0)
        self.note = QLineEdit()
        self.note.setPlaceholderText("Note")
        # hidden log view to keep textual logs (not shown in UI)
        self.log_view = QPlainTextEdit()
        self.log_view.setReadOnly(True)
        self.log_view.setVisible(False)

        self.start_stop_btn = QPushButton("Start")
        self.reset_zoom_btn = QToolButton()
        self.reset_zoom_btn.setText("Reset Zoom")
        self.reset_zoom_btn.setEnabled(False)
        self.edit_ports_btn = QPushButton("Port settings")

        self.status_label = QLabel("Ready")
        self.time_label = QLabel("00:00")
        self.time_label.setAlignment(Qt.AlignCenter)
        self.time_label.setStyleSheet("padding: 8px;")
        self.chart = QChart()
        self.chart_view = QChartView(self.chart)
        self.chart_view.setRenderHint(QPainter.Antialiasing)
        self.chart_view.setMinimumHeight(320)
        self.time_axis = QDateTimeAxis()
        self.time_axis.setFormat("HH:mm:ss")
        self.time_axis.setTitleText("Time")
        self.value_axis = QValueAxis()
        self.value_axis.setLabelFormat("%.1f")
        self.value_axis.setTitleText("Value")
        self.chart.addAxis(self.time_axis, Qt.AlignBottom)
        self.chart.addAxis(self.value_axis, Qt.AlignLeft)
        # Set initial visible window to avoid empty chart look
        now_dt = QDateTime.currentDateTimeUtc()
        self.time_axis.setRange(now_dt.addSecs(-300), now_dt.addSecs(300))
        self.value_axis.setRange(0, 1)
        self.chart.legend().setVisible(True)
        self.series_by_port: dict[str, QLineSeries] = {}

        # Resolve absolute log dir (if relative, base on settings path)
        log_dir_setting = Path(self.settings.get("app", {}).get("log_dir", "data/logs"))
        if not log_dir_setting.is_absolute():
            log_dir_setting = self.settings_path.parent / log_dir_setting
        self.log_dir = log_dir_setting

        # Logs tab widgets
        self.log_chart = QChart()
        self.log_chart_view = QChartView(self.log_chart)
        self.log_chart_view.setRenderHint(QPainter.Antialiasing)
        self.log_time_axis = QDateTimeAxis()
        self.log_time_axis.setFormat("HH:mm:ss")
        self.log_time_axis.setTitleText("Time")
        self.log_value_axis = QValueAxis()
        self.log_value_axis.setLabelFormat("%.1f")
        self.log_value_axis.setTitleText("Value")
        self.log_chart.addAxis(self.log_time_axis, Qt.AlignBottom)
        self.log_chart.addAxis(self.log_value_axis, Qt.AlignLeft)
        self.log_chart.legend().setVisible(True)
        self.log_series = QLineSeries()
        self.log_series.setName("log values")
        self.log_chart.addSeries(self.log_series)
        self.log_series.attachAxis(self.log_time_axis)
        self.log_series.attachAxis(self.log_value_axis)
        self.log_list = QListWidget()

        # Layouts per mock
        start_group = QGroupBox("Start / Stop")
        s_layout = QVBoxLayout()
        s_layout.addWidget(self.start_stop_btn)
        start_group.setLayout(s_layout)

        time_group = QGroupBox("Passed Time")
        t_layout = QVBoxLayout()
        t_layout.addWidget(self.time_label)
        t_layout.setContentsMargins(10, 15, 10, 15)
        time_group.setLayout(t_layout)

        port_group = QGroupBox("Port Lists")
        p_layout = QVBoxLayout()
        p_layout.addWidget(self.port_list)
        p_layout.addWidget(self.use_enabled)
        p_layout.addWidget(self.edit_ports_btn)
        port_group.setLayout(p_layout)

        info_group = QGroupBox("Cycle Info")
        info_layout = QFormLayout()
        info_layout.addRow("Roasting cycle name", self.cycle_name)
        info_layout.addRow("Bean type", self.bean_type)
        info_layout.addRow("Weight", self.weight)
        info_layout.addRow("Note", self.note)
        info_group.setLayout(info_layout)

        controls_group = QGroupBox()
        controls_layout = QVBoxLayout()
        controls_layout.addWidget(start_group)
        controls_layout.addWidget(time_group)
        controls_group.setLayout(controls_layout)

        main_grid = QGridLayout()
        main_grid.addWidget(controls_group, 0, 0)
        main_grid.addWidget(info_group, 0, 1)
        main_grid.addWidget(port_group, 0, 2)
        main_grid.addWidget(self.chart_view, 1, 0, 1, 3)
        main_grid.addWidget(self.status_label, 2, 0, 1, 3)
        main_grid.setRowStretch(0, 1)
        main_grid.setRowStretch(1, 6)
        main_grid.setRowStretch(2, 0)
        main_grid.setColumnStretch(0, 1)
        main_grid.setColumnStretch(1, 2)
        main_grid.setColumnStretch(2, 2)

        main_tab = QWidget()
        main_tab.setLayout(main_grid)

        inventory_tab = QWidget()
        inv_layout = QVBoxLayout()
        inv_layout.addWidget(QLabel("Inventory page (coming soon)"))
        inventory_tab.setLayout(inv_layout)

        tabs = QTabWidget()
        tabs.addTab(main_tab, "Main Page")
        tabs.addTab(inventory_tab, "Inventory Page")
        logs_tab = self._build_logs_tab()
        tabs.addTab(logs_tab, "Logs")
        tabs.currentChanged.connect(self.on_tab_changed)

        container = QWidget()
        container_layout = QVBoxLayout()
        container_layout.addWidget(tabs)
        container.setLayout(container_layout)
        self.setCentralWidget(container)

        self.use_enabled.stateChanged.connect(self.apply_enabled_selection)
        self.start_stop_btn.clicked.connect(self.toggle_start_stop)
        self.reset_zoom_btn.clicked.connect(self.reset_zoom)
        self.edit_ports_btn.clicked.connect(self.edit_ports)
        self.refresh_port_list()
        self.apply_enabled_selection()

    def toggle_start_stop(self) -> None:
        if self.running:
            self.stop_cycle()
        else:
            self.start_cycle()

    def start_cycle(self) -> None:
        if any(w.isRunning() for w in self.workers):
            QMessageBox.warning(self, "Running", "A cycle is already running.")
            return
        if self.use_enabled.isChecked():
            selected = [pid for pid, cfg in self.ports.items() if getattr(cfg, "enabled", True)]
        else:
            selected = [item.data(1000) for item in self.port_list.selectedItems()]
        if not selected:
            QMessageBox.warning(self, "No port", "Select at least one port.")
            return
        name_base = self.cycle_name.text().strip() or "gui_cycle"
        bean_type = self.bean_type.text().strip()
        weight = float(self.weight.value())
        note_text = self.note.text().strip()
        bean_slug = self._slugify(bean_type or "bean")
        note_slug = self._slugify(note_text or "note")
        weight_slug = self._slugify(str(weight))
        base_slug = self._slugify(name_base)
        cycle_base = f"{base_slug}_{bean_slug}_{weight_slug}_{note_slug}"

        self.workers = []
        for idx, port_id in enumerate(selected):
            port_cfg = self.ports[port_id]
            if hasattr(port_cfg, "enabled") and not port_cfg.enabled:
                continue
            # make each cycle name unique per port
            cycle_name = f"{cycle_base}_{port_id}"
            self.port_value_index[port_id] = getattr(port_cfg, "value_index", 0)
            worker = ReadWorker(
                port_cfg=port_cfg,
                log_dir=self.log_dir,
                cycle_name=cycle_name,
                client=self.client_combo.currentText(),
                address=getattr(port_cfg, "read_address", 0),
                count=getattr(port_cfg, "read_count", 1),
                interval=float(getattr(port_cfg, "poll_interval", 1.0)),
                value_index=getattr(port_cfg, "value_index", 0),
                bean_type=bean_type,
                weight=weight,
                note=note_text,
                display_name=base_slug,
            )
            worker.log_line.connect(self.append_log)
            worker.status.connect(self.update_status)
            worker.finished.connect(self.on_finished)
            worker.data_point.connect(self.add_point)
            self.workers.append(worker)

        self.reset_zoom_btn.setEnabled(True)
        self.start_time = datetime.utcnow()
        self.time_label.setText("00:00")
        self.timer.start(1000)
        self.start_stop_btn.setText("Stop")
        self.running = True
        self.set_cycle_inputs_enabled(False)
        # clear previous chart/log for this cycle only
        for series in list(self.series_by_port.values()):
            self.chart.removeSeries(series)
        self.series_by_port.clear()
        self.log_view.clear()
        # reset axes
        now_dt = QDateTime.currentDateTimeUtc()
        self.time_axis.setRange(now_dt.addSecs(-60), now_dt.addSecs(60))
        self.value_axis.setRange(0, 1)
        for worker in self.workers:
            self.log_view.appendPlainText(f"Starting cycle {worker.cycle_name} on {worker.port_cfg.id}")
            worker.start()

    def stop_cycle(self) -> None:
        for worker in self.workers:
            worker.stop()
        for worker in self.workers:
            if worker.isRunning():
                worker.wait(2000)
        self.running = False
        self.start_stop_btn.setText("Start")
        self.reset_zoom_btn.setEnabled(False)
        self.status_label.setText("Stopped")
        self.timer.stop()
        self.time_label.setText("00:00")
        self.set_cycle_inputs_enabled(True)

    def append_log(self, line: str) -> None:
        self.log_view.appendPlainText(line)
        self.log_view.ensureCursorVisible()

    def update_status(self, text: str) -> None:
        self.status_label.setText(text)
        self.log_view.appendPlainText(text)

    def update_elapsed(self) -> None:
        if not self.start_time:
            return
        delta = datetime.utcnow() - self.start_time
        minutes, seconds = divmod(int(delta.total_seconds()), 60)
        self.time_label.setText(f"{minutes:02d}:{seconds:02d}")

    def on_finished(self) -> None:
        if not any(w.isRunning() for w in self.workers):
            self.start_stop_btn.setText("Start")
            self.reset_zoom_btn.setEnabled(False)
            self.status_label.setText("Stopped")
            self.timer.stop()
            self.time_label.setText("00:00")
            self.running = False
            self.set_cycle_inputs_enabled(True)

    def apply_port_defaults(self) -> None:
        return

    def add_point(self, port_id: str, ts: float, value: float) -> None:
        if port_id not in self.series_by_port:
            series = QLineSeries()
            idx = self.port_value_index.get(port_id, 0)
            series.setName(f"{port_id} [idx {idx}]")
            self.chart.addSeries(series)
            series.attachAxis(self.time_axis)
            series.attachAxis(self.value_axis)
            self.series_by_port[port_id] = series
        series = self.series_by_port[port_id]
        dt = QDateTime.fromSecsSinceEpoch(int(ts))
        series.append(dt.toMSecsSinceEpoch(), value)
        # Extend X axis to cover entire cycle (no trimming)
        all_points = []
        for s in self.series_by_port.values():
            all_points.extend(self._series_points(s))
        if all_points:
            xs = [p.x() for p in all_points]
            min_ts = min(xs)
            max_ts = max(xs)
            # add small lookahead
            self.time_axis.setRange(QDateTime.fromMSecsSinceEpoch(int(min_ts)), QDateTime.fromMSecsSinceEpoch(int(max_ts + 60_000)))
        # adjust Y range
        all_vals = []
        for s in self.series_by_port.values():
            all_vals.extend([p.y() for p in self._series_points(s)])
        if all_vals:
            vmax = max(all_vals) + 1.0  # add headroom
            if vmax <= 0:
                vmax = 1.0
            self.value_axis.setRange(0, vmax)

    def reset_zoom(self) -> None:
        # reset axes to fit all points
        all_points = []
        for s in self.series_by_port.values():
            all_points.extend(self._series_points(s))
        if all_points:
            xs = [p.x() for p in all_points]
            min_ts = min(xs)
            max_ts = max(xs)
            self.time_axis.setRange(QDateTime.fromMSecsSinceEpoch(int(min_ts)), QDateTime.fromMSecsSinceEpoch(int(max_ts + 60_000)))
            all_vals = [p.y() for p in all_points]
            vmax = max(all_vals) + 1.0
            if vmax <= 0:
                vmax = 1.0
            self.value_axis.setRange(0, vmax)
        else:
            now_dt = QDateTime.currentDateTimeUtc()
            self.time_axis.setRange(now_dt.addSecs(-300), now_dt.addSecs(300))
            self.value_axis.setRange(0, 1)
        self.chart_view.chart().zoomReset()

    def refresh_port_list(self) -> None:
        self.port_list.clear()
        for pid, cfg in self.ports.items():
            label = f"{pid} ({cfg.device})"
            if hasattr(cfg, "enabled") and not cfg.enabled:
                label += " [disabled]"
            item = QListWidgetItem(label)
            item.setData(1000, pid)
            if hasattr(cfg, "enabled") and not cfg.enabled:
                item.setFlags(item.flags() & ~Qt.ItemIsEnabled)
            self.port_list.addItem(item)
        self.apply_enabled_selection()

    def edit_ports(self) -> None:
        dlg = PortEditorDialog(self.settings_path, self)
        if dlg.exec() == QDialog.Accepted:
            # reload settings/ports and refresh list
            self.settings = load_settings(self.settings_path)
            self.ports = load_port_configs(self.settings)
            self.refresh_port_list()
            self.refresh_log_list()

    def closeEvent(self, event) -> None:  # type: ignore[override]
        # Graceful shutdown: stop workers and wait
        if any(w.isRunning() for w in self.workers):
            self.status_label.setText("Shutting down...")
            self.stop_cycle()
        super().closeEvent(event)

    def apply_enabled_selection(self) -> None:
        if self.use_enabled.isChecked():
            # auto-select enabled ports, disable manual selection
            self.port_list.clearSelection()
            for i in range(self.port_list.count()):
                item = self.port_list.item(i)
                if item.isSelected():
                    continue
                pid = item.data(1000)
                cfg = self.ports.get(pid)
                if cfg and getattr(cfg, "enabled", True):
                    item.setSelected(True)
        else:
            # manual selection allowed
            pass

    def set_cycle_inputs_enabled(self, enabled: bool) -> None:
        self.cycle_name.setEnabled(enabled)
        self.bean_type.setEnabled(enabled)
        self.weight.setEnabled(enabled)
        self.note.setEnabled(enabled)

    @staticmethod
    def _slugify(text: str) -> str:
        safe = "".join(ch if ch.isalnum() or ch in "-._" else "_" for ch in text)
        return safe.strip("_") or "none"

    # Logs tab helpers
    def _build_logs_tab(self) -> QWidget:
        self.refresh_log_list()
        self.log_list.itemSelectionChanged.connect(self.load_selected_log)
        log_split = QSplitter(Qt.Horizontal)
        log_split.addWidget(self.log_chart_view)
        log_split.addWidget(self.log_list)
        log_split.setStretchFactor(0, 3)
        log_split.setStretchFactor(1, 1)
        tab = QWidget()
        tab_layout = QVBoxLayout()
        tab_layout.addWidget(log_split)
        tab.setLayout(tab_layout)
        return tab

    def refresh_log_list(self) -> None:
        self.log_list.clear()
        log_dir = self.log_dir
        if not log_dir.exists():
            return
        for path in sorted(log_dir.glob("*.log")):
            display = path.name
            try:
                first_line = path.read_text(encoding="utf-8").splitlines()[0]
                obj = json.loads(first_line)
                ts = obj.get("ts", "")
                payload = obj.get("data", {}) or obj.get("payload", {}) or obj
                session_info = None
                if isinstance(payload, dict):
                    session_info = payload.get("session_info")
                if not session_info and isinstance(obj, dict):
                    session_info = obj.get("session_info")
                name = ""
                weight = ""
                note = ""
                if isinstance(session_info, dict):
                    name = session_info.get("cycle_name", "") or ""
                    weight = str(session_info.get("weight", ""))
                    note = session_info.get("note", "") or ""
                ts_display = ts
                try:
                    dt_py = datetime.fromisoformat(ts)
                    ts_display = dt_py.strftime("%Y/%m/%d")
                except Exception:
                    dt = QDateTime.fromString(ts, Qt.ISODate)
                    if dt.isValid():
                        ts_display = dt.toString("yyyy/MM/dd")
                display = f"{ts_display} | {name} | {weight} | {note}"
            except Exception:
                # fallback to filename parsing without date
                _, name, weight, note = self._parse_log_filename(path.stem)
                display = f"{name} | {weight} | {note}"
            item = QListWidgetItem(display)
            item.setData(Qt.UserRole, str(path))
            self.log_list.addItem(item)

    def _parse_log_filename(self, stem: str) -> tuple[str, str, str, str]:
        """
        Expected pattern now: {name}_{bean}_{weight}_{note}_{port}_{timestamp}
        Returns ("", name, weight, note) with graceful fallbacks.
        """
        parts = stem.split("_")
        if len(parts) < 6:
            return "", stem, "", ""
        ts = parts[-1]
        port = parts[-2]
        note = parts[-3]
        weight = parts[-4]
        bean = parts[-5]
        name = "_".join(parts[:-5])
        return "", name, weight, note

    def load_selected_log(self) -> None:
        items = self.log_list.selectedItems()
        if not items:
            return
        path_str = items[0].data(Qt.UserRole)
        if not path_str:
            return
        path = Path(path_str)
        if not path.exists():
            return
        lines = path.read_text(encoding="utf-8").splitlines()
        points = []
        for line in lines:
            try:
                obj = json.loads(line)
                ts = obj.get("ts")
                data = obj.get("data", {})
                vals = None
                if isinstance(data, dict):
                    hr = data.get("holding_registers")
                    if isinstance(hr, dict):
                        if "registers" in hr and isinstance(hr["registers"], list):
                            vals = hr["registers"]
                        elif "values" in hr and isinstance(hr["values"], list):
                            vals = hr["values"]
                    elif isinstance(hr, list):
                        vals = hr
                if ts and vals and isinstance(vals, list) and vals:
                    dt = QDateTime.fromString(ts, Qt.ISODate)
                    if dt.isValid():
                        points.append((dt.toMSecsSinceEpoch(), float(vals[0])))
            except Exception:
                continue
        self.log_series.clear()
        if points:
            points = sorted(points, key=lambda x: x[0])
            for x, y in points:
                self.log_series.append(x, y)
            xs = [p[0] for p in points]
            ys = [p[1] for p in points]
            self.log_time_axis.setRange(QDateTime.fromMSecsSinceEpoch(int(min(xs))), QDateTime.fromMSecsSinceEpoch(int(max(xs))))
            ymax = max(ys) + 1.0
            if ymax <= 0:
                ymax = 1.0
            self.log_value_axis.setRange(0, ymax)
        else:
            now_dt = QDateTime.currentDateTimeUtc()
            self.log_time_axis.setRange(now_dt.addSecs(-60), now_dt.addSecs(60))
            self.log_value_axis.setRange(0, 1)

    def _series_points(self, series: QLineSeries) -> list:
        try:
            return list(series.points())
        except Exception:
            return []

    def on_tab_changed(self, index: int) -> None:
        tab = self.centralWidget().layout().itemAt(0).widget()  # tabs
        if isinstance(tab, QTabWidget):
            if tab.tabText(index) == "Logs":
                self.refresh_log_list()


def main() -> None:
    settings_path = ensure_runtime_paths()
    app = QApplication(sys.argv)
    window = MainWindow(settings_path=settings_path)
    window.resize(480, 640)
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()


def ensure_runtime_paths() -> None:
    """Ensure config/log paths exist and seed a default settings file if missing."""
    root = Path.cwd()
    config_dir = root / "config"
    data_dir = root / "data" / "logs"
    config_dir.mkdir(parents=True, exist_ok=True)
    data_dir.mkdir(parents=True, exist_ok=True)
    settings_path = config_dir / "settings.toml"
    sample_path = root / "config" / "settings.toml"
    if not settings_path.exists():
        if sample_path.exists():
            shutil.copy(sample_path, settings_path)
        else:
            settings_path.write_text(
                "# autogenerated settings\n[app]\nname='roaster_logger'\nlog_dir='data/logs'\n", encoding="utf-8"
            )
