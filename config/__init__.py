from __future__ import annotations

import importlib
import json
from pathlib import Path
from typing import Any, Dict, List, Tuple

_TOML_LIB = None


def _load_toml() -> Any:
    global _TOML_LIB
    if _TOML_LIB is not None:
        return _TOML_LIB
    try:
        import tomllib as _toml  # type: ignore
    except ModuleNotFoundError:
        _toml = importlib.import_module("tomli")
    _TOML_LIB = _toml
    return _toml


def load_settings(path: Path | str = "config/settings.toml") -> Dict[str, Any]:
    """Load application settings from TOML."""
    toml = _load_toml()
    path_obj = Path(path)
    with path_obj.open("rb") as fh:
        data = toml.load(fh)
    _validate_settings(data, path_obj)
    return data


def save_settings(settings: Dict[str, Any], path: Path | str = "config/settings.toml") -> Path:
    """Persist settings back to TOML. Limited to the known schema."""
    path_obj = Path(path)
    text = _render_settings(settings)
    path_obj.write_text(text, encoding="utf-8")
    return path_obj


def ports_by_id(settings: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
    """Map port id to port configuration."""
    ports = settings.get("ports") or []
    return {p["id"]: p for p in ports if "id" in p}


def ports_as_json(settings: Dict[str, Any]) -> str:
    """Helper to print ports block as pretty JSON for debugging."""
    return json.dumps(settings.get("ports", []), indent=2, ensure_ascii=False)


def get_port(settings: Dict[str, Any], port_id: str) -> Dict[str, Any] | None:
    return ports_by_id(settings).get(port_id)


def add_or_update_port(settings: Dict[str, Any], port_data: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
    """Add a new port or update existing. Returns ('added'|'updated', port_dict)."""
    ports = settings.setdefault("ports", [])
    if "id" not in port_data:
        raise ValueError("Port data must include 'id'")
    for idx, port in enumerate(ports):
        if port["id"] == port_data["id"]:
            merged = {**port, **port_data}
            _require_port_fields(merged, source="add_or_update_port")
            ports[idx] = merged
            return "updated", ports[idx]
    _require_port_fields(port_data, source="add_or_update_port")
    ports.append(port_data)
    return "added", port_data


def remove_port(settings: Dict[str, Any], port_id: str) -> bool:
    """Remove port by id. Returns True if removed."""
    ports = settings.get("ports", [])
    before = len(ports)
    settings["ports"] = [p for p in ports if p.get("id") != port_id]
    return len(settings["ports"]) < before


def _validate_settings(data: Dict[str, Any], source: Path) -> None:
    # Accept missing ports by defaulting to empty list
    if "ports" not in data:
        if "logging" in data and isinstance(data["logging"], dict) and "ports" in data["logging"]:
            # handle case where ports accidentally nested under logging
            data["ports"] = data["logging"].pop("ports")
        else:
            data["ports"] = []
    required_top = ["app", "logging"]
    for key in required_top:
        if key not in data:
            raise ValueError(f"Missing '{key}' in settings file {source}")
    for port in data.get("ports", []):
        for field in ("id", "device", "baudrate", "parity", "stopbits", "bytesize", "timeout", "unit_id"):
            if field not in port:
                raise ValueError(f"Missing port field '{field}' for port entry in {source}")


def _require_port_fields(port: Dict[str, Any], source: str) -> None:
    required = ("id", "device", "baudrate", "parity", "stopbits", "bytesize", "timeout", "unit_id")
    missing = [f for f in required if f not in port]
    if missing:
        raise ValueError(f"Missing port fields {missing} in {source}")


def _render_settings(data: Dict[str, Any]) -> str:
    def kv(key: str, val: Any) -> str:
        if isinstance(val, dict):
            inner = []
            for k, v in val.items():
                inner.append(kv(k, v))
            inner_str = ", ".join(s.split(" = ", 1)[1] if " = " in s else s for s in inner)
            return f"{key} = {{ {inner_str} }}"
        if isinstance(val, str):
            escaped = val.replace("\\", "\\\\").replace('"', '\\"')
            return f'{key} = "{escaped}"'
        if isinstance(val, bool):
            return f"{key} = {str(val).lower()}"
        return f"{key} = {val}"

    lines: list[str] = []
    lines.append("# Generated by config.save_settings")
    lines.append("[app]")
    for key in ("name", "env", "log_dir"):
        if key in data.get("app", {}):
            lines.append(kv(key, data["app"][key]))
    lines.append("")
    lines.append("[logging]")
    for key in ("level", "format", "max_bytes", "backup_count"):
        if key in data.get("logging", {}):
            lines.append(kv(key, data["logging"][key]))
    lines.append("")
    ports = data.get("ports", [])
    for port in ports:
        lines.append("[[ports]]")
        for key in (
            "id",
            "device",
            "baudrate",
            "parity",
            "stopbits",
            "bytesize",
            "timeout",
            "poll_interval",
            "unit_id",
            "register_map",
            "read_address",
            "read_count",
            "value_index",
            "enabled",
            "connect_retries",
            "connect_retry_delay",
            "read_retries",
            "read_retry_delay",
            "reconnect_on_read_error",
            "client_params",
        ):
            if key in port:
                lines.append(kv(key, port[key]))
        lines.append("")
    return "\n".join(lines).strip() + "\n"
